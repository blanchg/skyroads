<!DOCTYPE html>
<html>
<head>
	<title>Levels</title>

<script src="jdataview.js"></script>
<script src="jbinary.js"></script>
<script src="BitStream.js"></script>

<script>
var roads = {
  header: jBinary.Type({
  	read: function() {
  		var pos = this.binary.tell();
  		var firstOffset = this.binary.read(['uint16', true]);
  		this.binary.seek(pos);
  		return this.binary.read(['array', 'levelHeader', firstOffset / 2 / 2]);
  	},
  	write: function(values) {
  		this.binary.write(['array', 'levelHeader'], values);
  	}
  }),
  levelHeader: {
  	offset: ['uint16', true],
  	length: ['uint16', true]
  },
  level: jBinary.Template({
  	setParams: function(length) {
  		this.baseType = {
		  	gravity: ['uint16', true],
		  	fuel:    ['uint16', true],
		  	oxygen:  ['uint16', true],
		  	palette: ['array', 'byte', 72*3],
		  	road:    ['array', 'byte', length - 222]
  		}
  	}
  })
};

jBinary.load('ROADS.LZS', roads, function (err, binary) {
	var headers = binary.read('header');
	// console.log(headers);
	var levels = [];
	for (var i = 0; i < headers.length; i++) {
		// var i = 10;
		var header = headers[i];
		var length = 0;
		if (i == headers.length - 1) {
			length = binary.view.byteLength - header.offset;
		} else {
			length = headers[i+1].offset - header.offset;
		}
		level = binary.read(['level', length]);
		level.road = decompress(level.road, header.length);
		// break;
		levels.push(level);
	};
	console.log("Loaded: " + levels.length + " levels");
	renderLevel(levels[5]);

});

function renderLevel(level) {
	var road = level.road;
	console.log("level", level);
	console.log("level has", road.a.byteLength / 7 / 2, "lines");
	var length = road.a.byteLength;

	for (var i = 0; i < length; i+=14) {
		var out = "";
		for (var j = 0; j < 14; j+=2) {
			var blockcolour = road.a[i + j];
			var modifiers = road.a[i + j + 1];
			var topblockcolor = (blockcolour & 0xF0) >> 4;
			var bottomblockcolor = blockcolour & 0xF;
			out += (topblockcolor?topblockcolor.toString(16):" ") + (bottomblockcolor?bottomblockcolor.toString(16):" ");
			// out += (modifiers&1)?"T":" ";
		};
		console.log(out + "               " + i);
	};
}

function copyTo(from, fromOffset, count, to, toOffset) {
	var out = "";
	for (var i = 0; i < count; i++) {
		to[toOffset + i] = from[fromOffset + i];
		out += from[fromOffset + i];
	}
}

function decompress(road, finalLength) {

	var byteLength = road.length;
	var inBuf = new Uint8Array(byteLength);
	for (var i = 0; i < byteLength; i++) {
		inBuf[i] = road[i];
	};
	var input = new BitStream(inBuf);
	var outBuf = new ArrayBuffer(finalLength);

	var width1 = input.readBits(8);
	var width2 = input.readBits(8);
	var width3 = input.readBits(8);

	var index = 0;
	var dist = 0;
	var count = 0;
	var val = null;

	while (index < finalLength) {
		if (input.readBits(1) == 0) {
			dist = 2 + input.readBits(width2);
			count = 2 + input.readBits(width1);
			copyTo(outBuf, index - dist, count, outBuf, index);
			index += count;
		} else if (input.readBits(1) == 0) {
			dist = 2 + (1 << width2) + input.readBits(width3);
			count = 2 + input.readBits(width1);
			copyTo(outBuf, index - dist, count, outBuf, index);
			index += count;
		} else {
			val = input.readBits(8);
			outBuf[index] = val;
			index++;
		}
	}
	var output = new BitStream(outBuf);
	return output;
}
</script>
</head>
<body>

</body>
</html>